package ru.job4j.thread;

import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

/**
 * JCIP. Настройка библиотеки
 *
 * Библиотеку jcip поможет отслеживать ошибки в многопоточном окружении. Ее надо стараться использовать везде,
 * где появляются объекты мониторы.
 *
 * В тесте CountParallelTest видно что результат не является надежными.
 * Оценим, какие он имеет проблемы:
 * 1. Проблема гонок. Общий ресурс не синхронизирован.
 * 2. Проблема видимости общего ресурса. Одна нить считывает данные из кэша, другая из регистра.
 *
 * Чтобы решить эти проблемы, мы можем воспользоваться ключевым словом synchronized.
 * Для того, чтобы правильно определить, какие методы нам нужно синхронизировать, необходимо определить общие ресурсы.
 *
 * В наборе Java программиста есть удобный инструмент, который позволяет понять,
 * где у нас общие ресурсы и как мы их синхронизируем.
 * Для этого нам нужно подключить к нашему проекту библиотеку - jcip-annotations.
 * В этой библиотеке есть аннотации, которыми мы описываем класс.
 * Это нужно делать, чтобы облегчить понимание, где общие ресурсы и как мы их синхронизируем.
 * САМА БИБЛИОТЕКА СИНХРОНИЗАЦИЮ НЕ ОБЕСПЕЧИВАЕТ. Она только информирует программиста о том,
 * что у нас есть общие ресурсы и нам нужно аккуратно с ними работать.
 *
 * Аннотация @ThreadSafe говорит пользователям данного класса, что класс можно использовать в многопоточном режиме
 * и он будет работать правильно.
 *
 * Аннотация @GuardedBy("this") выставляется над общим ресурсом и имеет входящий параметр, который указывает
 * на объект монитора, по которому мы будем синхронизироваться.
 *
 * Программист должен работать с этим ресурсом только в критической секции,
 * которая синхронизируется по объекту монитора, который указан в аннотации.
 *
 * @author Alex_life
 * @version 1.0
 * @since 16.09.2022
 */
@ThreadSafe
public class CountParallel {
    @GuardedBy("this")
    private int value;

    public synchronized void increment() {
        this.value++;
    }

    public synchronized int get() {
        return this.value;
    }
}